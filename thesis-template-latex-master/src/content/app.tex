%----------------------------------------------------------------------------
\chapter{Android alkalmazás beszélőfelismerésre}
%----------------------------------------------------------------------------

A következő fejezetben bemutatom egy általam a beszélőfelismerés szemléltetésére készített android alkalmazás fő elemeit és működését, a kapcsolódó technológiákat és implementációs részleteket. Az alkalmazásban konkrét beszélőfelismerésre készített neurális hálózatokat használok fel. A cél nem egy új beszélőfelismerő modell készítése volt, hanem az eddigiek felhasználásával egy működő alkalmazás létrehozása.

Az alkalmazás kliens-szerver architektúrájú lesz. Az android kliens segítségével a felhasználó regisztrálhat a rendszerbe névvel és hanggal, majd az azonosítás opció megnyomásával hangmintát adva az alkalmazás eldönti, hogy regisztrálva van-e, és ha igen, akkor visszaadja az illető nevét.

\section{Modell predikció a felhőben vagy lokálisan?}


A szervernek tárolnia kell a felhasználóktól származó hangmintákat és a felhasználó azonosítás folyamata közben összehasonlítani őket. Az összehasonlítást egy sziámi neurális hálózat végzi. Az alkalmazás felépítését tekintve a legfontosabb kérdés, hogy ezt az összehasonlítást központilag egy felhőben a szerver, vagy a kliens oldali alkalmazás végezze. Mivel a modell végzi a predikciót, ettől a döntéstől függően azt a szerveren vagy a kliens eszközökön kell tárolni. Mindkét architektúrának vannak előnyei és hátrányai is.

Mivel esetünkben az alkalmazás kész, előre tanított modelleket használ, nincs szükség a modellek tanítására. Ennek ellenére ha a jövőben saját modellt szeretnénk használni felmerül a kérdés, hogy hol tanítsuk azt.

\begin{itemize}
	\item A felhőben hosztolt gépi tanulási szolgáltatások általában saját modelleket használnak. Mi a saját adatainkat átadjuk és a szolgáltatás gondoskodik a modell tanításáról. Ezután a predikciót egy API-n keresztül végezhetjük el. Figyelni kell arra, hogy ebben az esetben nem mindig miénk a modell. Ha nincs lehetőség tanítás után a modell letöltésére, akkor a predikció mindenképp a felhőben marad. Másrészről a magas szintű szolgáltatások kezelése könnyebb, nem kell érteni a neurális hálózatok tanításához, de nem elég flexibilisek. Általában nem változtathatunk a modellen és az API-n sem.
	
	\item A felhőben taníthatjuk a modellünket az erre készített szolgáltatások nélkül is nagyobb hozzáértést feltételezve. Ekkor megválaszthatjuk a modell típusát és a technológiákat (Tensorflow, Pytorch, stb.) és teljes mértékben miénk a modell és az irányítás. A lokális tanítással szemben további előny, hogy az erőforrásokat rugalmasan fel-le skálázhatjuk.
	
	\item Lokálisan is taníthatjuk a modellt. Ez főleg akkor éri meg, ha van elég erőforrásunk hozzá vagy a modell mérete nem indokolja több erőforrás használatát. Nagyobb modellek esetében a tanítási idő hosszú. Az árakat és az időt mérlegelve dönteni kell, hogy a lehetőségek közül melyiket indokolt választani.
\end{itemize}

Ha már rendelkezünk egy működő modellel, akkor el kell döntenünk, hogy a predikciót a felhőben vagy lokálisan az eszközön végezzük.

\begin{itemize}
	\item A hálózati kapcsolatot tekintve ha a predikciót lokálisan végezzük, nincs szükség internetkapcsolatra, predikció a készüléken történik. Ellenkező esetben a kliens interneten keresztül kérést küldd a szervernek, ami elvégzi a predikciót és visszaküldi a választ.
	\item A modellt felhőben a szerveren tárolni biztonságosabb. Lokális predikció esetén a modellt a készüléken tároljuk. Ilyenkor gondoskodni kell a biztonságáról, hogy ne lehessen visszafejteni azt (reverse engineering).
	\item A predikció sebessége is meghatározó szempont. Ha lokálisan, a mobiltelefon hatja végre, a felhőhöz képest kisebb erőforrással gazdálkodunk, ami miatt lassabb lesz a számítás. Viszont ha a felhőben végezzük, a kommunikációs overhead hozzáadódik a válaszhoz. Le kell mérni, hogy a kliens-szerver kommunikáció késleltetése mekkora az erőforráskülönbségből származó számítási időkhöz képest.
	\item Az alkalmazás architektúráját tekintve ha a modell és a predikció a szerveren történik, bármikor frissíthetjük, finomhangolhatjuk a modellt és ehhez nem kell a felhasználóknak frissítéseket letölteniük. Nincs szükség szinkronizációra. Az alkalmazás elosztott, elkülönült backend és frontend részekből áll, amelyek egy interfészen keresztül kommunikálnak, így ezek a komponensek lecserélhetők, csak az interfészt kell implementálniuk (API).
	\item Felhőbeli erőforrásokat használva az árat is figyelembe kell venni. Minél több felhasználó használ egy alkalmazást és amennyiben a számítás központilag a felhőben történik, annál több erőforrásra van szükség. Nagy előnye a készüléken végzett predikciónak, hogy jól skálázódik. Több felhasználó esetén nincs szükség több erőforrásra.
\end{itemize}

Jelen alkalmazás egy beszélőfelismerő szoftvert szemléltet, amelyet a valóságban vállalatok üzemeltetnek beléptető kapuval biometrikus azonosításként. Központi szerverre szükség van a regisztrált felhasználók adatainak biztonságos tárolása és a könnyű szinkronizáció miatt. Ha feltesszük, hogy a beléptető rendszert nem több mint tízezer ember azonosítására használják és a belépés szekvenciálisan történik, óriási erőforrásokat sem kell használni, mert a szerver egy időben legfeljebb a beléptető kapuk száma szerinti számítást kell végezzen, ami korlátos. Ezeket figyelembe véve úgy döntöttem, hogy a modell tárolása és a predikció szerveren fog történni.

\section{Alkalmazás architektúra és általános működés}

Mivel az alkalmazás tárolja a regisztrált felhasználók hangmintáit és a modellt; a biztonság, a könnyű központi adminisztráció és hogy nincs szükség szinkronizációra mind megerősíti a kliens-szerver architektúra szükségességét és előnyeit, így peer-to-peer megoldás fel sem merült.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=100mm, keepaspectratio]{figures/app-register.png}
	\caption{Beszélőfelismerő alkalmazás: Regisztrációs fázis.}
	\label{fig:app-register}
\end{figure}

A \ref{fig:app-register} ábrán látható kliens a felhőben futó szerverrel egy REST API-n keresztül kommunikál. A kliens segítségével a felhasználó regisztrál a rendszerbe, ezután azonosíthatja magát. A regisztrációs fázis működése a következő:

\begin{enumerate}
	\item A felhasználó hangját és nevét a kliens alkalmazás rögzíti.
	\item A kliens a hangmintát és a nevet elküldi a szervernek a REST API-n keresztül.
	\item A szerver előfeldolgozza a hangfájlt, majd menti a névvel együtt az adatbázisba.
\end{enumerate}

Miután a felhasználók regisztráltak, az alkalmazás a hangjuk alapján azonosítani tudja őket. Az azonosítási fázis lépéseit a \ref{fig:app-identify} ábra mutatja.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=100mm, keepaspectratio]{figures/app-identify.png}
	\caption{Beszélőfelismerő alkalmazás: Regisztrációs fázis.}
	\label{fig:app-identify}
\end{figure}

\begin{enumerate}
	\item A kliens rögzíti az azonosítani kívánt felhasználó hangját.
	\item A hangmintát továbbítja a szervernek.
	\item A szerveren futó alkalmazás a hangfájlt előfeldolgozza és eltárolja.
	\item A hangmintákat az adatbázisból betölti és azonosítandó - nem azonosítandó párokat készít belőle.
	\item A hangminta párokat a modell bemenetére adja.
	\item A modell kiszámolja a hangminták közötti hasonlósági pontokat. Ezután az alkalmazás a hasonlósági küszöbszámot figyelembe véve dönt arról, hogy azonosítható-e a felhasználó.
	\item A szerver válaszol az azonosított felhasználó nevével, vagy közli, hogy a felhasználó nincs a rendszerben.
\end{enumerate}

\section{Felhasznált modellek}

\subsection{Voicemap}

A \emph{voicemap} egy beszélőfelismerő GitHub repository, ami tartalmazza a modell kódját, a tanítást, különböző teszteket és egy optimalizált előre tanított modellt. Az implementációhoz \emph{Kerast} használ.

\subsubsection{Az implementált modellek}

Két modellt vizsgál; egy sziámi neurális hálózatot és egy sima konvolúciósat klasszifikációval. A sziámi hálózat alapja egy konvolúciós enkóder, amely a nyers hangmintákból kinyeri a jellemzőket és egy hangvektorokat állít elő belőlük. Az enkóder hálózat a következő konvolúciós blokkokból áll:

\begin{itemize}
	\item Conv1D 32-es méretű filterekkel, ahol a filterek száma szorzódik a blokk számával. Az aktivációs függvény \emph{ReLu}.
	\item BatchNormalization
	\item SpatialDropout1D
	\item MaxPool1D
\end{itemize}

Négy ilyen konvolúciós blokk követi egymást, majd egy \emph{GlobalMaxPool1D} és egy \emph{Dense} réteg a hangvektor méretével.

A sziámi hálózat alapja két enkóder hálózat, amelynek súlyai megosztottak, tehát úgy is tekinthetünk rá, hogy egy enkóder hálózatra két bemenetet adhatunk. A hangminták a hálózaton áthaladva jellemző vektorokká alakulnak. Ezt a részt a konvolúciós enkóder végzi. Ezután a két vektor közötti távolságot a sziámi hálózat kiszámolja.

Az implementált távolságmetrikák a következők:

\begin{itemize}
	\item \emph{weighted\_l1}: Az eredeti one-shot cikk szerinti távolságmetrika.
	\item \emph{uniform\_euclidean}: Euklideszi távolság két vektor között.
	\item \emph{cosine\_distance}: Koszinusz távolság, azaz a két vektor által bezárt szög koszinuszát méri.
\end{itemize}

A kiszámolt távolság ezután minden esetben áthalad egy szigmoid aktivációs függvényű \emph{Dense} rétegen, ami $0$ és $1$ közé nyomja az eredményt.

\subsubsection{A k-way n-shot feladat}

A repository tartalmaz egy utility szkriptet a hangminták preprocesszálásához és few-shot kiértékeléshez, amit később a saját alkalmazásomban is felhasználtam. Ez tartalmazza többek között az \emph{n\_shot\_task\_evaluation} függvényt is, ami \emph{k-way n-shot} feladatokkal teszteli a modellt. Az alábbi argumentumokat adhatjuk meg:

\begin{itemize}
	\item  \emph{model}: A tesztelendő modell.
	\item  \emph{dataset}: A tesztmintákat tartalmazó adathalmaz objektum.
	\item  \emph{preprocessor}: Előfeldolgozó függvény a minták csökkentett mintavételezésére és standardizálására.
	\item  \emph{num\_task}: A feladatok száma.
	\item  \emph{n}: Hány hangminta tartozik egy beszélőhöz a segédhalmazban.
	\item  \emph{k}: Ennyi beszélő, azaz osztály van a segédhalmazban.
	\item  \emph{network\_type}: Sziámi vagy klasszifikációs.
	\item  \emph{distance\_metric}: Sziámi hálózat esetén a hangvektorok közötti távolságmetrika.
\end{itemize}

\subsubsection{Beszédadatbázisok és generátorok}

A voicemap tanításhoz és teszteléshez a \emph{LibriSpeech} adatbázis \emph{dev-clean}, \emph{train-clean-100} és \emph{train-clean-360} adathalmazokat használja, amelyek sorban $40$, $251$ és $921$ különböző beszélőtől tartalmaznak nyers hangfájlokat. Egy adathalmazt egy adatgenerátor osztály reprezentál ami a keras.util.Sequence osztályból származik. Az adatgenerátorok nagy adathalmazok esetén hasznosak, amikor az egész adathalmaz nem fér bele a memóriába. Ilyen esetekben egyesével generálnak adatokat.

A \emph{keras.util.Sequence} osztályból való leszármaztatás miatt az adatgenerátorban implementálni kell a \emph{\_\_len\_\_} és \emph{\_\_get\_item\_\_} függvényeket. Előbbi az adathalmaz méretét adja vissza, utóbbi annak indexelését teszi lehetővé. Továbbá biztosítja, hogy egy epochon belül egy mintával csak egyszer tanítjuk a modellt.

A \emph{LibriSpeechDataset} osztály ezen kívül képes még egy beszélőtől és különböző beszélőktől származó hangminta párok előállítására, tanításhoz hangminta pár kötegek építésére, amelyekben az azonos és különböző beszélőktől származó párok esélye 50\%. Az objektum létrehozásakor választhatunk sima és sztochasztikus mód között. Míg az előbbi a minta elejétől számolva, utóbbi véletlenszerűen választja ki a megadott hosszúságú szakaszt egy mintán belül. A módtól eltekintve ha egy hangmintát kiegészíthetünk 0-ákból álló \emph{paddinggel} is a megfelelő méretre. Fontos függvénye még a \emph{build\_n\_shot\_task}, ami validációhoz és kiértékeléshez \emph{k-way n-shot} feladatokat hoz létre. A függvény visszaad egy hangmintát az azonosítandó beszélőtől és egy generált segédhalmazt, ami tartalmaz mintát az azonosítandó és egyéb beszélőktől is az $n$ és $k$ paraméterek alapján.

\subsubsection{Tanítás}

A sziámi és a sima klasszifikációs hálózat nagyrészt közös paraméterekkel rendelkeznek. A fő különbség, hogy míg a sziámi veszteségfüggvénye bináris keresztentrópia, és a veszteség az alapján dől el, hogy a hangminta pár egyazon vagy más beszélőktől származik, a klasszifikációs hálózat kategórikus keresztentrópiát használ, tehát a hangmintát megpróbálja besorolni $k$ osztály valamelyikébe $k$ beszélő esetén. A közös paraméterek:

\begin{itemize}
	\item hangminta hossza: 3 sec
    \item batchsize: 64
    \item filterek száma: 128
    \item jellemző vektor dimenzió: 64
    \item dropout: 0
    \item steps\_per\_epoch: 500
    \item kiértékelési feladatok száma: 500
    \item n\_shot\_klasszifikáció: 1
    \item k\_way\_klasszifikáció: 5
\end{itemize}

Tehát mindkét modell optimizált hiperparamétereket használ, \emph{Adam} optimizálót és veszteségfüggvényként keresztentrópiát. Egy epoch $500$ batch iterációból áll és egy batch méret $64$.
Az epochok végén három callback fut le.
Minden epoch végén kiértékelés történik: 500 \emph{1-shot 5-way} feladat átlagos eredménye jelzi a pontosságot. Amennyiben ez növekszik a modellről \emph{checkpoint} készül (\emph{ModelCheckpoint}).
Továbbá ha a kiértékelés során a pontosság nem nő, a \emph{ReduceLROnPlateau} csökkenti a tanulási rátát.


\subsubsection{Kísérletek és optimalizálás}

A repositoryban számos kísérlet található a legjobb teljesítmény elérésére. A \emph{wide\_vs\_tall} szkript leméri, hogy a modell hogyan teljesít különböző hosszúságú hangmintákkal tanítva. A mérés alatt \emph{1-shot 5-way} feladatokkal, azaz 5 különböző beszélőtől 1-1 beszédmintával validálta a modellt.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/voicemap-wide-vs-tall.png}
	\caption{Voicemap: Regisztrációs fázis.}
	\label{fig:voicemap-wide-vs-tall}
\end{figure}

A \ref{fig:voicemap-wide-vs-tall} ábrán látható, hogy a hangminta méretét növelve a modell valóban jobban tanul, de a több adat miatt megnövekedik a tanítási idő és több memóriára van szükség. A grafikon mutatja, hogy 3 másodperc után a validáció stagnálni kezd, ezért az erőforrásokat és a tanítási időt figyelembe véve ez tűnik a legjobb választásnak.

A \emph{grid\_search\_siamese\_network} szkript hiperparaméter optimizációt végez a sziámi hálózaton a filterek számát, a hangmintákból képzett vektorok hosszát és a dropoutot vizsgálva. A talált legjobb paraméterek:

\begin{itemize}
	\item filterek száma: 128
	\item jellemző vektor dimenzió: 64
	\item dropout: nincs
\end{itemize}

A \emph{k\_way\_accuracy} kísérlet a hiperparaméter optimalizált modellt teljesítményét méri le különböző \emph{n-shot k-way} feladatokkal. A pontosságot a következő ábra mutatja:

\begin{figure}[!ht]
	\centering
	\includegraphics[width=150mm, keepaspectratio]{figures/voicemap-n-shot-k-way.png}
	\caption{Voicemap: n-shot k-way pontosság.}
	\label{fig:voicemap-n-shot-k-way}
\end{figure}

\emph{1-shot k-way} feladatok esetén a sziámi hálózat átlagosan jobban teljesít sima klasszifikációsnál, de \emph{5-shot k-way} feladatok esetén már az utóbbi kerül fölénybe. Ez valószínűleg annak köszönhető, hogy 5 hangminta - beszélő párból a sima osztályozó hálózat már jobban meg tudta tanulni a beszélőket a sziáminál.

\subsubsection{Saját kísérletek}

\section{Implementáció}

\subsection{Kliens alkalmazás}

A kliens oldali android alkalmazást Android Studio segítségével készítettem el. Az alkalmazás felhasználói felületeket tartalmaz regisztrációhoz és azonosításhoz, képes hang rögzítésére wav formátumban és ennek http protokollon keresztüli továbbítására a szerverhez. A szerver válaszát az azonosításról jelzi a felhasználónak. 

\subsubsection{Projekt felépítése}

Az Android Studios projekt főbb elemei a következők:

\begin{itemize}
	\item \emph{AndroidManifest.xml}: Engedélyek és activityk deklarálása.
	\item \emph{java}: Activitykhez tartozó és egyéb java osztályok.
	\item \emph{res/layout}: A felhasználói felülethez tartozó xml leírók.
	\item \emph{build.gradle}: Gradle modul konfiguráció és dependenciák módosítására.
\end{itemize}

\subsubsection{Engedélyek}

Bizonyos műveletek elvégzéséhez az Android operációs rendszeren engedélyek szükségesek. Az engedélyek a művelet típusától függően \emph{normál} vagy \emph{veszélyes} osztályba tartoznak. Ha az alkalmazás olyan műveletet akar végrehajtani, amihez engedély szükséges, azt deklarálni kell az android projekt manifest fájljában.

A \emph{normál} engedélyeket az operációs rendszer ezután automatikusan biztosítja, míg a \emph{veszélyesekhez} a felhasználó engedélyét kéri. Korábbi android verziókban az engedélyek megadási az alkalmazás telepítésekor történt, de később ez megváltozott. A minimum Android 6.0-át (23-as API szint) használó készülékeken a felhasználó már nem telepítéskor, hanem futási időben kell megadja az engedélyeket. Egy felugró ablak listázza, hogy az alkalmazás milyen engedélyeket kér, ezután választhat, hogy melyeket adja meg neki.

A beszélőfelismerő alkalmazás a következő engedélyeket használja:

\begin{itemize}
	\item RECORD\_AUDIO: A mikrofon használata hangfelvételhez.
	\item READ\_EXTERNAL\_STORAGE: A külső tárhely olvasásához.
	\item WRITE\_EXTERNAL\_STORAGE: A külső tárhely írásához.
	\item INTERNET: Internetelérés hálózati kommunikációhoz.
\end{itemize}

\subsubsection{Tárhely}

Az alkalmazás a felhasználótól vett hangmintát \emph{wav} formátumban tárolja el. A \emph{wav} egy tömörítetlen audioformátum és mivel később hangmintából jellemzőkinyerés történik, így nem veszíthetünk információt a jellemzőkről a tömörítés miatt. Később bemutatom, hogy a tömörített audioállományok milyen hatással vannak a modell teljesítményére.

Az Android beépített \emph{MediaRecorder} osztálya a \emph{wav} formátumot nem támogatja és nincs erre készült más beépített Java osztály sem, ezért egy erre készített kódot használtam fel Selvaline blogjáról. Selvaline \emph{WavRecorder} osztálya az általunk beállított paraméterekkel (csatorna, mintavételi frekvencia, stb.) felveszi a hangot és egy \emph{wav} fájlban tárolja azt.

Az Android operációs rendszeren használhatunk külső és belső tárhelyet. A belső tárhely előnye, hogy a fájlokhoz csak az alkalmazás fér hozzá és annak eltávolításakor a hozzá kapcsolódó fájlok is törlődnek. A külső tárhely előnye esetünkben, hogy könnyű mountolni. Ha a készüléket USB-vel számítógéphez csatlakoztatjuk, a külső tárhelyen lévő fájlokat böngészhetjük. Ez a hangfájl tesztelése miatt célszerű választás volt. 



\subsubsection{Felhasználói felület}

 A felhasználói felület három részből áll és minden felülethez egy-egy \emph{Activity} osztály tartozik. A fő felületen választhat a felhasználó a regisztráció és az azonosítás között. A fő felületen az \emph{Enroll} gombot megnyomva a regisztrációs, illetve ehhez hasonlóan az \emph{Identify} opcióval az azonosító felületre ugorhatunk.


\begin{figure}[!ht]
	\centering
	\includegraphics[width=40mm, keepaspectratio]{figures/app-main-screen.png}
	\caption{Menü.}
	\label{fig:app-main-screen}
\end{figure}

A regisztrációs felületen megadjuk a nevet, majd a \emph{Record} gombra kattintva három másodperc múlva elindul a hangfelvétel, ami négy másodpercen keresztül tart. A felületen megjelenő információ folyamatosan tájékoztatja a felhasználót a hangfelvétel folyamatáról.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=40mm, keepaspectratio]{figures/app-register-screen-1.png}
	\includegraphics[width=40mm, keepaspectratio]{figures/app-register-screen-2.png}
	\includegraphics[width=40mm, keepaspectratio]{figures/app-register-screen-3.png}
	\caption{Felhasználói felület regisztrációhoz.}
	\label{fig:app-register-screen-1}
\end{figure}

A zöld fejlécen a vissza nyílra kattintva visszajutunk a főmenübe. Ezt az opciót a manifest fájlban a \emph{parentActivityName} tag megadásával érhetjük el.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=40mm, keepaspectratio]{figures/app-identify-screen-1.png}
	\caption{Felhasználói felület azonosításhoz.}
	\label{fig:app-identify-screen-1}
\end{figure}

\newpage
A főmenüből az azonosító felületre lépve az \emph{Identify} gombra kattintva szintén visszaszámlálásra elindul a hangrögzítés, ami négy másodperig tart. Ezután megkapjuk a választ; az azonosított felhasználó nevét, vagy a nem sikerült azonosítani üzenetet.

\subsubsection{Osztálydiagram és részletes működés}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=130mm, keepaspectratio]{figures/app-class-diag.png}
	\caption{Beszélőfelismerő alkalmazás: Osztálydiagram.}
	\label{fig:app-class-diag}
\end{figure}

A \emph{MainActivity} osztály tartozik a főmenühöz. Amikor a főmenübe lépünk, az \emph{onCreate} metódus hívódik meg, amely ellenőrzi, hogy az alkalmazásnak megvannak-e a szükséges engedélyei a \emph{hasPermission} segédmetódus által. Ha igen akkor nem tesz semmit, egyébként a felhasználótól az összes engedély megadását kéri.

Az \emph{enroll} metódus a felületen az \emph{Enroll} gombhoz, az \emph{identify} az \emph{Identify} gombhoz tartozik. Mindkét függvény létrehoz egy-egy \emph{Intent}-et ami a hivatalos definíció szerint egy elvégzendő művelet absztrakt leírása. Az \emph{Intent} valójában arra jó, hogy egy felületről egy másik felületre lépjünk. A kiinduló felületen egy gombra kattintva (pl. \emph{Enroll}), a gombhoz tartozó listener metódus (\emph{enroll()}) hívódik meg, ami létrehoz egy \emph{Intentet} paraméterként átadva az elérni kívánt felülethez tartozó \emph{Activity} osztályt (\emph{EnrollActivity}). Ezután az \emph{Intentet} elindítva átlépünk a felületre.

A regisztrációs felületre lépve az \emph{onCreate} metódus meghívásakor az \emph{EnrollActivity} példányosít egy \emph{WavRecorder} objektumot a fájl elérési útjával paraméterezve. A \emph{record} metódus visszaszámlál, kiírja a felhasználónak az időzített üzeneteket, és elindítja majd megállítja a \emph{WavRecordert}.

Az időzítést az ajánlás szerint a \emph{Handler} osztály segítségével végeztem. Ennek előnye, hogy az időzített feladatokat egy háttérszálon futtatja, így nem blokkol. Így nem történhet meg, hogy egy hosszabb feladat elvégzése miatt a felületen nem kattinthatunk amíg az nincs kész.

Az \emph{IdentifyActivity} osztály nagyon hasonlóan működik. A különbség, hogy a \emph{EnrollActivity}-hez képest nem küld nevet és más címre küldi a hangfájlt.

Mindkét osztály a \emph{UploadAudio} objektumot használ a fájl szerverhez való elküldéséhez. Az \emph{UploadAudio} egy \emph{OkHttpClient} http klienst használ és \emph{multipart/form} Http POST kérést küld a szerver felé a hangfájllal ill. regisztrációkor a névvel. Ezután egy callback metódussal várja a szerver válaszát, amit az azonosító felületre továbbít.

\subsection{Szerver}

Szerver oldalon egy Flask webalkalmazás fut felhőben és REST API-val rendelkezik. Fogadja a klienstől érkező hangfájlokat, előfeldolgozza és tárolja őket. Azonosításkor a modellen prediktál, majd visszaküldi az eredményt a kliensnek.

\subsubsection{Flask}

A Flask egy Python nyelvhez készült web mikrokeretrendszer. Mikrokeretrendszernek nevezzük a minimális webalkalmazás keretrendszereket, amelyekből általában hiányoznak a autentikációs, autorizációs könyvtárak, az objektum-relációs leképzés stb.

A Flask előnye, hogy nagyon gyorsan és könnyedén lehet vele REST API-t készíteni és elindítani egy webalkalamzást. Nincs szükség más könyvtárakra, toolokra hozzá.

\subsubsection{Projekt felépítése}

\begin{itemize}
	\item \emph{app}: A webalkalmazást indító és a logikát tartalmazó (előfeldolgozás, predikció, fájlok kezelése) illetve konfigurációt kezelő Python szkriptek könyvtára (app.py, preprocess.py).
	
	\begin{itemize}
		\item app/app.py
		\item app/preprocess.py
		\item app/config.py
	\end{itemize}
	
	\item \emph{data}: Tartalmazza a klienstől regisztrációs és azonosítani kívánt \emph{wav} fájlokat és a preprocesszált állományokat.
	
	\begin{itemize}
		\item data/wav: Az eredeti, klienstől érkezett hangfájlok.
		\item data/preprocessed\_audio: Az előfeldolgozott hangfájlok. 
		\item data/identify: Az azonosítandó felhasználóhoz tartozó hangfájlok.
	\end{itemize}
	
	\item \emph{model}: A beszélőfelismerésre használt modelleket tároló mappa.
\end{itemize}

\subsubsection{Részletes működés}

Az \emph{app.py} szkript négy fontos függvényt tartalmaz. Ezek közül az \emph{enroll} és az \emph{identify} függvények a REST API-t implementálják, a \emph{preprocess} a hangfájlok előfeldolgozását, a \emph{predict} a prediktálást végzi.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=130mm, keepaspectratio]{figures/flask-class-diag.png}
	\caption{Flask szerver: Osztálydiagram.}
	\label{fig:flask-class-diag}
\end{figure}

Az \emph{app.py} először létrehoz egy Flask objektumot, ezután betölti a megfelelő konfigurációt a \emph{config.py} szkriptben deklarált valamelyik objektummal. Betölti a modellt, majd elindítja az alkalmazást, ami a \emph{/enroll} és \emph{/identify} útvonalakon \emph{POST} kérésekre vár.

Mivel az alkalmazás egy prototípus és nincs szükség felhasználóspecifikus adatok tárolására néven kívül, adatbázis helyett egy \emph{dictionary} tárolja az egyedi azonosító - felhasználónév párokat egy fájlba szerializálva, a hangfájlok pedig egyedi azonosítónévvel vannak eltárolva.

Ha egy kérés az \emph{enroll} útvonalon érkezik, az alkalmazás létrehoz egy egyedi azonosítót, és ezen a néven menti az audiofájlt. Ezután az azonosítókat és neveket tartalmazó \emph{dictionaryt} kiegészíti az aktuális bejegyzéssel. Az hangfájlt preprocesszálja, majd ha minden rendben ment visszatért egy \emph{Http OK (200)} státuszüzenettel.

A \emph{preprocess} függvénynek két fő paramétere van: a hangminta hossza és a \emph{downsampling}, vagyis a csökkentett mintavételezési ráta. Mivel a jelenleg használt modell $3$ másodperces és $4$ kHz-en mintavételezett hangmintákat vár a bemenetére, a saját $4$ másodperces hangmintákból $3$ másodperces darabokat vág ki a közepétől számolva $1,5$-$1,5$ másodperces távolságra. Erre azért van szükség, hogy ha a felhasználó kicsit később kezd el beszélni vagy hamarabb hagyja abba, a felvétel elején vagy végén lévő szünet ne kerüljön bele a mintába.
\newline

A csökkentett mintavételezés az eltérő mintavételi frekvencia miatt szükséges. Az Androidot futtató készülékek $8$ és $16$ bites PCM mellett $8$, $16$ és $44.1$ kHz-es mintavételi frekvenciákat támogatnak. Esetünkben a modellt $4$ kHz-en tanították a saját hangminták pedig $8$ kHz-esek ezért $2$-es csökkentett mintavételezés szükséges.

A \emph{identify} útvonalra érkező kéréseket a \emph{identify} függvény fogadja. Menti majd preprocesszálja a hangfájlt, meghívja a predickciót és visszatér az eredménnyel.

A \emph{predict} függvény feladata a predikció elvégzése. Paraméterként a felhasználó azonosítóját kapja. Ez alapján párokat képez az azonosítandó felhasználó és a többi regisztrált felhasználó hangmintáiból és ezeket a modell bemenetére adja. A modell minden egyes párhoz kiszámol egy hasonlósági vektort. Ezeket és a hasonlósági küszöböt figyelembe véve dönt az eredményről.
\newline

A \emph{preprocess.py} szkript tartalmaz egy whiten() nevű függvényt, ami standardizálja a hangmintákat. Egy hangmintát egész számok sorozata reprezentál (PCM kódolás 4 vagy 16 biten). Először kivonja az átlagot minden számból, így a hangminta átlaga 0 lesz. Ezután újraskálázza a számokat, hogy ne legyenek kiugró amplitúdó értékek.

A \emph{preprocess\_instances} végzi el a standardizálást és a csökkentett mintavételezést. A \emph{BatchPreProcessor} objektum pedig egy wrapper osztály, hogy az előfeldolgozást sziámi hálózatokhoz és sima osztályozó hálózatokhoz készült \emph{([input1, input2], output)} és \emph{(inputs, outputs)} formában is könnyedén elvégezhessük.